/* use this to call GCF to leverage AUTH & browser caching
  AUTH - all calls to GCF require a urlParam named cypherKey - which is generated by the current page URL route parameter q
  CACHE - all GET calls to GCF will be cached by {{z}}_{{method}}_{{cypherKey}}
*/
var API = {};

API.init = function() {
  // solve for z (url param)
  var urlParams = API.getUrlParams();
  if (urlParams.z) API.z = urlParams.z || ''; // API.z is the "auth" a client sends to api for access
  if (localStorage) API.zKey = localStorage.getItem(`key_${API.z}`);

  // enable global error reporting
  window.addEventListener("error", function (e, f, g) {
    API.errorLog({
      name: 'window.eventListener',
      message: e.message,
      stack: e.stack,
      url: (window && window.location) ? window.location.href : null,
      type: 'client_js_error'
    });
    return false;
  });

  API.purgeApiCache(); // clean up localstorage of old caches
  API.currentCall = null;

  window.onbeforeunload = function(){
    if (API.currentCall) API.currentCall.abort();
  }
}

API.gcf = async function(shortUrl, options = {}) { // shortUrl = 'v2-sendSlackMessge
  /* args:
    httpMethod, // POST GET...
    method, // GCF function name
    params, // ?asdf=1234
    package, // obj to be passed into POST as JSON
    onSuccess, // executed after success
    onFailure // executed after failure
  */
  if (!options.method) options.method = 'GET';
  var shortSplit = shortUrl.split('?');
  options.gcf = shortSplit[0];
  options.urlParams = shortSplit[1] || '';

  // 1. check the browser cache
  var cachedData = null;
  try {
    cachedData = API.getCache(options.gcf, options.cacheMS);
  } catch (e) {
    API.errorLog({
      name: 'API.getCache',
      message: e.message,
      stack: e.stack,
      url: (window && window.location) ? window.location.href : null,
      type: 'client_js_error'
    });
  }
  if (cachedData) {
    return cachedData;
  }

  if (!options.params) options.params = '';

  // 2. check the browser for a auth key
  var urlParams = API.getUrlParams();
  if (urlParams.z) API.z = urlParams.z || ''; // API.z is the "auth" a client sends to api for access
  if (!API.z && Admin) {
    try { API.z = Admin.key } catch (e) { /* do nothing */ }
  }
  if (localStorage) API.zKey = localStorage.getItem(`key_${API.z || Admin.key}`);

  // 3. make the call
  var callURL = `https://us-central1-custom-family-gifts.cloudfunctions.net/v2-call?cypherKey=${API.zKey || API.z}&method=${options.gcf}&${options.urlParams}`;
  if (options.body) options.method = 'POST';
  if (!options.headers) options.headers = {};
  if (options.method != 'GET') options.headers['Content-Type'] = "application/json";

  // attach current href for debugging
  options.headers.current_href = location.href;

  var request = await fetch(callURL, options);
  var requestBody = await request.text();
  var requestData = JSON.parse(requestBody);

  return requestData;
};

/* Caching logic */
API.cacheExpire = 60000; // 60s
API.saveCache = function(method, data) {
  if (!localStorage) return;
  data.cacheDatetime = new Date().toISOString();
  try {
    localStorage.setItem(API.getCacheKey(method), JSON.stringify(data));
  } catch (e) {
    console.warn(e);
  }
}

API.purgeApiCache = function() {
  // checks all the cache keys to remove old cache data that's expired.
  var nowEpoch = new Date().getTime();
  for (var key in localStorage) {
    var keyParts = key.split('_');
    if (keyParts[0] == 'api') {
      if (keyParts[keyParts.length-1] < nowEpoch) localStorage.removeItem(key);
    }
  }
}

API.getCacheKey = function(method) {
  // add epoch - midnight of next day for key that is unique to each day
  // also easily num compared to see if expired or not
  var nowEpoch = new Date().getTime();
  var day = 86400000;
  var uniqueDayKey = nowEpoch - (nowEpoch % day) + day;
  return `api_${method}_${API.z}_${window.location.search}_${uniqueDayKey}`;
}

API.getCache = function(method, cacheMS) {
  if (!localStorage) return;
  if (cacheMS == undefined) cacheMS = API.cacheExpire;
  var cacheKey = API.getCacheKey(method);
  var cached = localStorage.getItem(cacheKey);
  if (cached) {
    var cacheData = JSON.parse(cached);
    // see how old cached copy is
    var cacheDatetime = new Date(cacheData.cacheDatetime);
    cacheData.cacheAgeMs = new Date() - cacheDatetime;
    delete cacheData.cacheDatetime;
    if (cacheData.cacheAgeMs < cacheMS) {
      console.log('cachehit ' + cacheKey);
      cacheData.cacheHit = true; // show that this came from cache
      return cacheData;
    } else {
      // remove from browser cache
      localStorage.removeItem(cacheKey);
    }
  }
  return null;
}

API.clearCache = function(method) {
  if (!localStorage) return;
  localStorage.removeItem(`${method}_${API.z}`);
}

API.errorLog = function(log) {
  log.log = 'error_log';
  log.userAgent = 'unknown';
  log.timezone = new Date().getTimezoneOffset();
  if (window && window.navigator) log.userAgent = window.navigator.userAgent;
  var callURL = `https://us-central1-custom-family-gifts.cloudfunctions.net/v2-log?`;
  $.ajax(callURL,{
    method: `POST`,
    headers: { "Content-Type": "application/json" },
    data: JSON.stringify(log)
  }).done(function(data, status) {
    // console.log(data);
    // console.log(status);
  });
}

API.params = {}; // what actually gets pass to API. contains default values and can be influenced by urlParams
API.getUrlParams = function() {
  // gets the params from url
  var url = window.location.search;
  var paramSplit2 = (url.split('?')[1]) ? url.split('?')[1].split('&') : [];
  var result = {};
  var paramSplit3 = paramSplit2.forEach((item) => { // count=13
    var itemSplit = item.split('=');
    var key = itemSplit[0];
    var value = itemSplit[1];
    if (value == undefined || value == null) value = '';
    result[key] = decodeURIComponent(value.replace(/\+/g, ' '));
  });
  return result;
};
API.setUrlParam = function(name, value) { // pushes param changes to url
  var params = API.getUrlParams();
  params[name] = value;
  API.paramsToUrl(params);
};
API.paramsToUrl = function(paramObj) {
  // reflect this to API.params at this time, which includes default paramters for API
  API.params = Object.assign({}, API.params, paramObj);

  var result = '';
  Object.keys(paramObj).forEach((key) => {
    if (key === undefined || key === null) return;
    if (paramObj[key] != null && paramObj[key] != undefined && paramObj[key] != '') {
      if (result != '') result += '&';
      result += `${key}${(paramObj[key]) ? '='+encodeURIComponent(paramObj[key]) : ''}`;
    }
  });
  window.history.pushState('page', 'cfg', window.location.pathname + '?' + result);
  return result;
}

API.init();

API.promiseAll = async function(promiseByKey) {
  /*
  accepts obj of fn definitions e.g.
  {
    getItems: { fn: myFunc, params: [] }  // fn NOT invoked - params = array of arguments
    getCupcakes: { fn: myFunc, params: [] }
  }
  returns
  { getItems: {...}, getCupcakes: {...} }
  OR throws first promise's Error
  */
  var results = {};
  var promiseFunctions = [];
  var fns = {};
  var promiseAllStart = new Date();
  var promiseCount = 0;
  for (let key in promiseByKey) {
    promiseCount++;
    // wrap the function execution in a structured way
    fns[key] = async () => {
      var promiseStart = new Date();
      await API.sleep((promiseCount - 1) * 50); // stagger the calls by 75
      results[key] = await promiseByKey[key].fn.apply(null, promiseByKey[key].params).catch(e => {
        console.warn(`promise [${key}] failed`);
        throw e;
      });

      results[key+'_elapsedMs'] = new Date() - promiseStart;
    }
    promiseFunctions.push(fns[key]()); // non await invocation, leave that up to Promise.all
  }
  // call Promise All
  var promiseSuccess = true;
  await Promise.all(promiseFunctions).catch((e) => {
    promiseSuccess = false;
    results.error_obj = e;
  });
  if (!promiseSuccess) {
    throw results.error_obj;
  }

  // count up the elapsedMS
  var totalElapsed = 0;
  var highestElapsed = 0;
  for (let key in results) {
    if (!key.includes('_elapsedMs')) {
      if (results[key+'_elapsedMs'] > highestElapsed) highestElapsed = results[key+'_elapsedMs'];
      totalElapsed += results[key+'_elapsedMs'];
    }
    // delete results[key].elapsedMs;
  }
  results.promiseSequentialMs = totalElapsed;
  results.promiseSavedMs = totalElapsed - highestElapsed;
  results.promiseActualMs = highestElapsed;

  return results;
}

API.sleep = function (ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}